import { verifyJWT } from "../middlewares/auth.middleware.js"
import { Product } from "../models/products.model.js";
import { Purchase } from '../models/purchase.model.js'
import { User } from "../models/user.model.js"
import { ApiError } from "../utils/ApiErrors.js"
import { ApiResponse } from "../utils/ApiResponse.js"
import { Ticket } from "../models/Tickets.model.js";
import { sendOtpEmail, sendPasswordResetSuccessEmail, sendResetPasswordEmail, sendTicketEmailsToParties, sendWelcomeEmailToCustomer, sendWelcomeEmailToEngineer } from "../utils/mailer.js";
import crypto from "crypto";
import bcrypt from 'bcrypt'


const generateRandomPassword = (length = 10) => {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@$!%*?&";
    let password = "";
    for (let i = 0; i < length; i++) {
        password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return password;
};


const generateAccessAndRefreshToken = async (userId) => {
    try {
        const user = await User.findById(userId)

        const accessToken = user.generateAccessToken()
        const refreshToken = user.generateRefreshToken()

        user.refreshToken = refreshToken
        await user.save({ validateBeforeSave: false })

        return { accessToken, refreshToken }

    } catch (error) {
        console.log("Error while generateing access and refresh token", error)
        throw new Error("Error while generating access and refresh token");
    }
}

// const registerCustomer = async (req, res, next) => {
//     try {
//         const userDetails = req.body
//         // console.log("user Details", email, firstName)

//         if ([userDetails.organization, userDetails.email].some((field) => {
//             return field?.trim() === ""
//         })) {
//             return res.status(400).json({ message: "Organization & Email fields are required" })
//         }

//         const existingUser = await User.findOne({ email: userDetails.email })

//         console.log("Organization is already Exist with this email", existingUser)

//         if (existingUser) {
//             return res.status(400).json({ message: "Organization is already exist with this email", existingUser })
//         }

//         const autoGeneratedPassword = generateRandomPassword(12);

//         const user = await User.create({
//             firstName: userDetails.firstName,
//             lastName: userDetails.lastName,
//             email: userDetails.email,
//             organization: userDetails.organization,
//             password: autoGeneratedPassword,
//             role: userDetails.role || "customer",
//             address_1: userDetails.address_1,
//             address_2: userDetails.address_2,
//             country: userDetails.country,
//             pinNumber: userDetails.pinNumber,
//             phoneNumber: userDetails.phoneNumber,
//         })

//         const userCreated = await User.findById(user._id).select("-password")

//         if (user.role === "customer") {
//             await sendWelcomeEmailToCustomer(user.email, user.organization);
//         } else if (user.role === "engineer") {
//             await sendWelcomeEmailToEngineer(user.email, user.firstName, user.lastName);
//         }

//         if (!userCreated) {
//             res.status(500).json({ message: "Something went wrong while registering user" })
//         }

//         return res.status(201).json(new ApiResponse(201, "User registered successfully", { userCreated, generatedPassword: autoGeneratedPassword }));

//     } catch (error) {
//         next(error);
//     }
// }

const registerCustomerAndEngineer = async (req, res, next) => {
    try {
        const userDetails = req.body;
        const role = userDetails.role || "customer";

        let requiredFields = [];

        if (role === "customer") {
            requiredFields = ["email", "organization", "country", "phoneNumber"];
        } else if (role === "commissioning_engineer") {
            requiredFields = ["email", "firstName", "lastName", "country", "phoneNumber"];
        }

        const missing = requiredFields.filter((field) => {
            const value = userDetails[field];
            if (value === undefined || value === null) return true;
            if (typeof value === "string" && value.trim() === "") return true;
            if (typeof value !== "string" && !value) return true;
            return false;
        });

        if (missing.length > 0) {
            return res.status(400).json({
                message: `Missing required fields for ${role}: ${missing.join(", ")}`,
            });
        }

        const existingUser = await User.findOne({ email: userDetails.email });

        if (existingUser) {
            return res.status(400)
                .json(new ApiError(400, "A user with this email already exists", ["Duplicate email"]));
        }

        const autoGeneratedPassword = generateRandomPassword(12);

        const user = await User.create({
            firstName: userDetails.firstName,
            lastName: userDetails.lastName,
            email: userDetails.email,
            organization: userDetails.organization || null,
            password: autoGeneratedPassword,
            role: role,
            address_1: userDetails.address_1,
            address_2: userDetails.address_2,
            country: userDetails.country,
            pinNumber: userDetails.pinNumber,
            phoneNumber: userDetails.phoneNumber,
        });

        const userCreated = await User.findById(user._id).select("-password");

        if (role === "customer") {
            await sendWelcomeEmailToCustomer(user.email, user.organization, autoGeneratedPassword);
        } else if (role === "commissioning_engineer") {
            await sendWelcomeEmailToEngineer(user.email, user.firstName, user.lastName, autoGeneratedPassword);
        }

        return res.status(201).json(
            new ApiResponse(201, "User registered successfully", {
                userCreated,
                generatedPassword: autoGeneratedPassword,
            })
        );

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack));
    }
};


const login = async (req, res, next) => {

    try {
        console.log("user details", req.body)
        const { email, password } = req.body

        console.log("user details", email, password)
        if (!email || !password) {
            return res.status(400).json({ message: "All fields are required" })
        }


        const user = await User.findOne({ email })

        console.log("users", user)
        if (!user) {
            return res.status(400).json({ message: "user does not exist" })
        }

        const isPasswordCorrect = await user.isPasswordCorrect(password)

        if (!isPasswordCorrect) {
            return res.status(400).json({ message: "Password is not valid" })
        }

        const { accessToken, refreshToken } = await generateAccessAndRefreshToken(user._id)

        const loggedInUser = await User.findById(user._id).select("-password -refreshToken")

        const options = {
            httpOnly: true,
            secure: false
        }

        const response = new ApiResponse(200, "User logged in successfully", {
            user: loggedInUser,
            accessToken,
            refreshToken,
        });

        return res
            .status(response.statusCode)
            .cookie("accessToken", accessToken, options)
            .cookie("refreshToken", refreshToken, options)
            .json(response);

    } catch (error) {
        console.error("Error in login:", error);
        const errResponse = new ApiError(500, "Internal Server Error", [error.message]);
        return res.status(errResponse.statusCode).json(errResponse);
    }
}

const logout = async (req, res) => {
    try {
        await User.findByIdAndUpdate(
            req.user._id,
            { $unset: { refreshToken: 1 } },
            { new: true }
        );

        const options = {
            httpOnly: true,
            //   secure: process.env.NODE_ENV === "production", 
        };
        res
            .clearCookie("accessToken", options)
            .clearCookie("refreshToken", options);

        const response = new ApiResponse(200, "User logged out successfully");
        return res.status(response.statusCode).json(response);
    } catch (error) {
        console.error("Logout error:", error);
        const errResponse = new ApiError(500, "Internal Server Error", [error.message]);
        return res.status(errResponse.statusCode).json(errResponse);
    }
};

const forgotPassword = async (req, res) => {
    try {
        const { email } = req.body;

        if (!email) {
            return res.status(400).json(new ApiError(400, "Email is required"));
        }

        const user = await User.findOne({ email });

        if (!user) {
            return res.status(404).json({ message: "User not found" });
        }

        const resetToken = user.generatePasswordResetToken();

        await user.save({ validateBeforeSave: false });

        const resetUrl = `${process.env.FRONTEND_URL}/reset-password/${resetToken}`;

        await sendResetPasswordEmail(user.email, resetUrl);

        return res.status(200).json({
            message: "Reset password link sent to your email",
            resetToken,
            resetUrl
        });

    } catch (error) {
        console.error("Forgot Password Error:", error);
        return res.status(500).json({ message: "Internal Server Error" });
    }
};


const resetNewPassword = async (req, res) => {
    try {
        const { token } = req.params;
        const { password, confirmPassword } = req.body;

        if (!password || !confirmPassword) {
            return res.status(400).json({ message: "All fields are required" });
        }

        if (password !== confirmPassword) {
            return res.status(400).json({ message: "Passwords do not match" });
        }

        const hashedToken = crypto
            .createHash("sha256")
            .update(token)
            .digest("hex");

        const user = await User.findOne({
            resetPasswordToken: hashedToken,
            resetPasswordExpiry: { $gt: Date.now() },
        });

        console.log("reset user", user);

        if (!user) {
            return res.status(400).json({ message: "Invalid or expired token" });
        }

        user.password = password;

        user.resetPasswordToken = undefined;
        user.resetPasswordExpiry = undefined;

        await user.save();

        return res.status(200).json({
            message: "Password reset successful",
        });

    } catch (error) {
        console.error("Reset Password Error:", error);
        return res.status(500).json({ message: "Internal Server Error" });
    }
};


const changeCurrentPassword = async (req, res, next) => {
    try {
        const { oldPassword, newPassword, confirmPassword } = req.body;

        if (!oldPassword || !newPassword || !confirmPassword) {
            return res.status(400).json({ message: "All fields are required" });
        }

        if (newPassword !== confirmPassword) {
            return res.status(400).json({ message: "New password and confirm password do not match" });
        }

        const passwordRegex =
            /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;

        if (!passwordRegex.test(newPassword)) {
            return res.status(400).json({
                message:
                    "Password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one number, and one special character.",
            });
        }

        const user = await User.findById(req.user?._id);
        if (!user) {
            return res.status(404).json({ message: "User not found" });
        }

        const isPasswordValid = await user.isPasswordCorrect(oldPassword);
        if (!isPasswordValid) {
            return res.status(400).json({ message: "Old password is incorrect" });
        }

        if (oldPassword === newPassword) {
            return res.status(400).json({ message: "New password must be different from old password" });
        }

        user.password = newPassword;
        await user.save();

        user.refreshToken = undefined;
        await user.save();

        return res
            .status(200)
            .json(new ApiResponse(200, "Password changed successfully", {}));

    } catch (error) {
        console.error("Error changing password:", error);
        return res
            .status(500)
            .json(new ApiError(500, "Internal Server Error", [error.message]));
    }
}

const refreshAccessToken = async (req, res, next) => {
    const incomingRefreshToken = req.cookies.refreshToken || req.body.refreshToken

    if (!incomingRefreshToken) {
        return res.status(400).json({ message: "Unauthorized Token" })
    }
    try {
        const decodeToken = await verifyJWT(incomingRefreshToken, process.env.REFRESH_TOKEN_SECRET)
        const user = await User.findById(decodeToken?._id)

        if (!user) {
            throw new ApiError(401, "Invalid refresh token")
        }

        if (incomingRefreshToken !== user?.refreshToken) {
            throw new ApiError(401, "Refresh Token is expired or used")
        }

        const options = {
            httpOnly: true,
            // secure: true
        }

        const { accessToken, newRefreshToken } = await generateAccessAndRefreshToken(user._id)

        return res
            .status(200)
            .cookie("accessToken", accessToken, options)
            .cookie("refreshToken", newRefreshToken, options)
            .json(new ApiResponse(200, accessToken, refreshAccessToken), "Access Token Refreshed")
    } catch (error) {
        throw new ApiError(400, error.message || "Invalid Token")
    }
}

const addNewProduct = async (req, res, next) => {
    try {
        const { productName, productDetails } = req.body;
        console.log("body:", productName, productDetails)

        if (!productName || productName.trim() === "") {
            return res
                .status(400)
                .json(
                    new ApiError(400, "Product name is required", ["productName is mandatory"])
                );
        }
        console.log("body1:", productName, productDetails)

        const existingProduct = await Product.findOne({ productName: productName.trim() });
        if (existingProduct) {
            return res
                .status(400)
                .json(
                    new ApiError(400, "Product already exists", [`Product "${productName}" already exists`])
                );
        }

        const product = await Product.create({
            productName: productName.trim(),
            productDetails: productDetails?.trim(),
        });

        return res
            .status(201)
            .json(new ApiResponse(201, "Product added successfully", product));
    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const addProductToCustomer = async (req, res, next) => {
    try {
        const { projectNumber, productId, productSerialNumber, date } = req.body
        console.log("body 1 :", "number:", projectNumber, "prodID:", productId, "sr.no;", productSerialNumber, "data:", date)

        const { customerId } = req.params;

        console.log("userId", customerId)

        if (!projectNumber || !productId || !date) {
            return res
                .status(400)
                .json(
                    new ApiError(
                        400,
                        "productId, projectNumber, date are required.",
                        ["projectNumber, productId, and date must be provided"]
                    )
                );
        }

        const user = await User.findById(customerId);
        if (!user) {
            return res
                .status(404)
                .json(new ApiError(404, "Customer not found.", [`No customer with id: ${customerId}`]));
        }

        const product = await Product.findById(productId);
        if (!product) {
            return res
                .status(404)
                .json(new ApiError(404, "Product not found.", [`No product with id: ${productId}`]));
        }

        const existingPurchase = await Purchase.findOne({ projectNumber });
        if (existingPurchase) {
            return res
                .status(400)
                .json(new ApiError(400, "Project number already exists.", [`Project number "${projectNumber}" is already used`]));
        }

        const newPurchase = await Purchase.create({
            user: customerId,
            product: productId,
            projectNumber,
            date: new Date(date),
            productSerialNumber,
        });

        return res
            .status(201)
            .json(new ApiResponse(201, "Product assigned to customer successfully", newPurchase));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const updateAssignedProduct = async (req, res, next) => {
    try {
        const { purchaseId } = req.params;
        const { projectNumber, productId, productSerialNumber, date } = req.body;

        console.log("purchase dd:", "id:", purchaseId, productSerialNumber, date)

        const purchase = await Purchase.findById(purchaseId);
        if (!purchase) {
            return res
                .status(404)
                .json(new ApiError(404, "Purchase not found", [`No purchase with id: ${purchaseId}`]));
        }
        console.log("update details", "purchaseId", purchaseId, "body:", projectNumber, productId, productSerialNumber, date)

        if (projectNumber && projectNumber !== purchase.projectNumber) {
            const exists = await Purchase.findOne({ projectNumber });
            if (exists) {
                return res
                    .status(400)
                    .json(new ApiError(400, "Project number already exists", [`Project number "${projectNumber}" is already used`]));
            }
            purchase.projectNumber = projectNumber;
        }

        if (productId) {
            const product = await Product.findById(productId);
            if (!product) {
                return res
                    .status(404)
                    .json(new ApiError(404, "Product not found", [`No product with id: ${productId}`]));
            }
            purchase.product = productId;
        }

        if (productSerialNumber) {
            purchase.productSerialNumber = productSerialNumber;
        }

        if (date) {
            purchase.date = new Date(date);
        }

        console.log("update purchase detail: ", purchase, productId, productSerialNumber, date)
        await purchase.save();

        return res.status(200).json(
            new ApiResponse(
                200,
                "Project updated successfully",
                purchase
            )
        );

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const getCustomerDetailsAndPurchases = async (req, res) => {
    try {
        const { userId } = req.params;

        const purchase = await Purchase.find({ user: userId })
            .populate("product", "productName productDetails")
            .populate("user", "-password -refreshToken")
            .sort({ createdAt: -1 });

        return res
            .status(200)
            .json(new ApiResponse(200, "Customer products fetched successfully", purchase));
    } catch (error) {
        console.error("Error in getCustomerProducts:", error);
        return res.status(500).json(new ApiError(500, "Internal Server Error", [error.message]));
    }
};

const createTicket = async (req, res) => {
    try {
        const { productName, projectNumber, organization, issueDetails, issueType } = req.body;

        if (!productName || !projectNumber || !organization || !issueDetails || !issueType) {
            return res.status(400).json(
                new ApiError(400, "All mandatory fields must be provided", [
                    "productName, projectNumber, organization, issueDetails, issueType are required to enter."
                ])
            );
        }
        // console.log("body2:",productName, projectNumber, organization, issueDetails ,issueType)

        const organizationExists = await User.findOne({ organization });

        if (!organizationExists) {
            return res.status(400).json(
                new ApiError(400, "Invalid organization", [
                    `No organization found with name: ${organization}`
                ])
            );
        }
        const productExists = await Product.findOne({ productName });
        if (!productExists) {
            return res.status(400).json(
                new ApiError(400, "Invalid productName", [
                    `No product found with name: ${productName}`
                ])
            );
        }

        const purchaseExists = await Purchase.findOne({ projectNumber }).populate("product").populate("user");;
        if (!purchaseExists) {
            return res.status(400).json(
                new ApiError(400, "Invalid projectNumber", [
                    `No purchase found with projectNumber: ${projectNumber}`
                ])
            );
        }

        if (purchaseExists.product.productName !== productName) {
            return res.status(400).json(
                new ApiError(400, "Product mismatch", [
                    `Product name does not match the product linked with this projectNumber`
                ])
            );
        }

        const customerEmail = purchaseExists.user.email;

        const ticket = await Ticket.create({
            productName,
            projectNumber,
            organization,
            issueType,
            issueDetails,
            customerEmail,
            // dateTime: dateTime || Date.now(),
            user: req.user?._id || null
        });

        return res.status(201).json(
            new ApiResponse(201, "Ticket created successfully", ticket)
        );

    } catch (error) {
        console.error("Error in createTicket:", error);
        return res.status(500).json(
            new ApiError(500, "Internal Server Error", [error.message])
        );
    }
};

// const getTickets = async (req, res) => {
//     try {
//         const tickets = await Ticket.find().sort({ createdAt: -1 });

//         return res.status(200).json(
//             new ApiResponse(200, "Tickets fetched successfully",   tickets )
//         );

//     } catch (error) {
//         console.error("Error in getTickets:", error);
//         return res.status(500).json(
//             new ApiError(500, "Internal Server Error", [error.message])
//         );
//     }
// };

const getTickets = async (req, res) => {
    try {
        let tickets;

        if (req.user.role === "customer") {
            tickets = await Ticket.find({ customerEmail: req.user.email })
                .sort({ createdAt: -1 });
        } else {
            tickets = await Ticket.find().sort({ createdAt: -1 });
        }

        const formatted = tickets.map(t => {
            const date = new Date(t.createdAt);

            const formattedDate = date.toLocaleDateString("en-GB", {
                day: "2-digit",
                month: "short",
                year: "numeric",
            });

            const formattedTime = date.toLocaleTimeString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                hour12: true
            });

            return {
                ...t._doc,
                createdAtFormatted: `${formattedTime} ${formattedDate}`,
            };
        });

        return res.status(200).json(
            new ApiResponse(200, "Tickets fetched successfully", formatted)
        );

    } catch (error) {
        console.error("Error in getTickets:", error);
        return res.status(500).json(
            new ApiError(500, "Internal Server Error", [error.message])
        );
    }
};



const getTicketById = async (req, res) => {
    try {
        const { ticketId } = req.params;

        // Validate ID
        if (!ticketId || ticketId.trim() === "") {
            return res.status(400).json(
                new ApiError(400, "Ticket ID is required", [
                    "ticketId parameter is missing"
                ])
            );
        }

        // Find ticket
        const ticket = await Ticket.findById(ticketId)
            .populate("user", "email role")
            .populate("organization", "name");

        if (!ticket) {
            return res.status(404).json(
                new ApiError(404, "Ticket not found", [
                    `No ticket exists with ID: ${ticketId}`
                ])
            );
        }

        return res.status(200).json(
            new ApiResponse(200, "Ticket fetched successfully", ticket)
        );

    } catch (error) {
        console.error("Error in getTicketById:", error);
        return res.status(500).json(
            new ApiError(500, "Internal Server Error", [error.message])
        );
    }
};

const getAllCustomers = async (req, res, next) => {
    try {
        const customers = await User.find({ role: "customer" }).select("-password -refreshToken");

        return res.status(200).json(
            new ApiResponse(200, "Customers fetched successfully", customers)
        );
    } catch (error) {
        return next(
            new ApiError(500, "Error Fetching customer list", [error.message])
        )
    }
};

const getAllEngineers = async (req, res, next) => {
    try {
        const engineers = await User.find({ role: "commissioning_engineer" }).select("-password");

        return res.status(200).json(
            new ApiResponse(200, "Engineers fetched successfully", engineers)
        );
    } catch (error) {
        return next(
            new ApiError(500, "Error Fetch Engineer's list", [error.message])
        );
    }
};

const getAllPurchasedProductsOfCustomer = async (req, res, next) => {
    try {
        const { customerId } = req.params;

        const user = await User.findById(customerId);
        if (!user) {
            return res
                .status(404)
                .json(new ApiError(404, "Customer not found.", [`No customer with id: ${customerId}`]));
        }

        const purchases = await Purchase.find({ user: customerId })
            .populate("product")

        return res
            .status(200)
            .json(new ApiResponse(200, "Purchases fetched successfully", purchases));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const getAllProducts = async (req, res, next) => {
    try {
        const products = await Product.find();

        return res
            .status(200)
            .json(new ApiResponse(200, "Products fetched successfully", products));
    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const updateNewProduct = async (req, res, next) => {
    try {
        const { productId } = req.params;
        const { productName, productDetails } = req.body;

        if (!productId) {
            return res.status(400).json({ message: "Product ID is required" });
        }

        if (productName && productName.trim() !== "") {
            const existingProduct = await Product.findOne({
                productName: productName.trim(),
                _id: { $ne: productId }
            });

            if (existingProduct) {
                return res
                    .status(400)
                    .json(new ApiError(400, "Another product with the same name already exists", [`Product name "${productName}" is already used`]));
            }
        }

        const updatedProduct = await Product.findByIdAndUpdate(
            productId,
            {
                ...(productName ? { productName: productName.trim() } : {}),
                ...(productDetails ? { productDetails: productDetails.trim() } : {})
            },
            { new: true }
        );

        if (!updatedProduct) {
            return res.status(404).json({ message: "Product not found" });
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Product updated successfully", updatedProduct));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const ticketDetailsSendToParties = async (req, res) => {
    try {
        const { ticketId } = req.params;
        const { optionalEmail, comment, synergyNumber } = req.body;

        console.log("optionEmail , comment , synergyNumber", optionalEmail, comment, synergyNumber)

        if (!comment) {
            return res.status(400).json({
                message: "Comment is required",
            });
        }

        const ticket = await Ticket.findById(ticketId);
        if (!ticket) {
            return res.status(404).json({ message: "Ticket not found" });
        }

        ticket.comment = comment;
        if (optionalEmail) ticket.optionalEmail = optionalEmail;
        if (synergyNumber) ticket.synergyNumber = synergyNumber;

        ticket.status = "Resolved";

        await ticket.save();

        const emailPayload = {
            ticketId: ticket._id,
            projectNumber: ticket.projectNumber,
            productName: ticket.productName,
            issueDetails: ticket.issueDetails,
            issueType: ticket.issueType,
            organization: ticket.organization,
            customerEmail: ticket.customerEmail,
            status: ticket.status,
            comment,
            synergyNumber: synergyNumber || "N/A",
        };

        if (optionalEmail) {
            await sendTicketEmailsToParties(optionalEmail, emailPayload);
        }

        await sendTicketEmailsToParties(ticket.customerEmail, emailPayload);

        return res.status(200).json(
            new ApiResponse(
                200,
                "Project updated successfully",
                ticket
            )
        );
    } catch (error) {
        console.error("Error in takeTicketAction:", error);
        return res.status(500).json({
            message: "Internal Server Error",
            error: error.message,
        });
    }
};


const getCustomerDetails = async (req, res) => {
    try {
        const { userId } = req.params;

        const customer = await User.findById(userId);

        if (!customer) {
            return res.status(404).json(
                new ApiError(404, "Customer not found")
            );
        }

        return res.status(200).json(
            new ApiResponse(200, "Customer fetched successfully", customer)
        );

    } catch (error) {
        console.error("Error in getCustomerDetails:", error);
        return res.status(500).json(
            new ApiError(500, "Internal Server Error", [error.message])
        );
    }
};

const updateCustomer = async (req, res, next) => {
    try {
        const { userId } = req.params;
        const updates = req.body;

        delete updates.role;

        if (updates.email) {
            const existingUser = await User.findOne({ email: updates.email, _id: { $ne: userId } });
            if (existingUser) {
                return res
                    .status(400)
                    .json(new ApiError(400, "Another user with this email already exists"));
            }
        }

        const updatedUser = await User.findByIdAndUpdate(
            userId,
            { $set: updates },
            { new: true, runValidators: true, select: "-password" }
        );

        if (!updatedUser) {
            return res.status(404).json({ message: "User not found" });
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Customer updated successfully", updatedUser));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const getCustomerById = async (req, res) => {
    try {
        const customer = await User.findById(req.params.userId);

        if (!customer) {
            return res
                .status(404)
                .json(new ApiError(404, "Customer not found"));
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Customer fetched successfully", customer));

    } catch (error) {
        return next(
            new ApiError(500, "Error fetching customer", [error.message], error.stack)
        );
    }
};


const getUpdatedProduct = async (req, res) => {
    try {
        const product = await Product.findById(req.params.id);

        if (!product) {
            return res
                .status(404)
                .json(new ApiError(404, "Product not found"));
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Product fetched successfully", product));
    } catch (error) {
        return next(
            new ApiError(500, "Server error", [error.message], error.stack)
        );
    }
};


const updateEngineer = async (req, res, next) => {
    try {
        const { id } = req.params;
        const updates = req.body;

        delete updates.role;

        if (updates.email) {
            const existingUser = await User.findOne({
                email: updates.email,
                _id: { $ne: id }
            });

            if (existingUser) {
                return res
                    .status(400)
                    .json(new ApiError(400, "Another engineer with this email already exists"));
            }
        }

        const updatedEngineer = await User.findByIdAndUpdate(
            id,
            { $set: updates },
            { new: true, runValidators: true, select: "-password" }
        );

        if (!updatedEngineer) {
            return res
                .status(404)
                .json(new ApiError(404, "Engineer not found", [`No engineer found with id: ${id}`]));
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Engineer updated successfully", updatedEngineer));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const getEngineerById = async (req, res, next) => {
    try {
        const { id } = req.params;

        const engineer = await User.findOne({
            _id: id,
            role: "commissioning_engineer"
        }).select("-password -refreshToken");

        if (!engineer) {
            return res
                .status(404)
                .json(new ApiError(404, "Engineer not found", [`No engineer found with id: ${id}`]));
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Engineer fetched successfully", engineer));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const fileUpload = async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: "No file uploaded" });
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = req.body.filename || `document-${timestamp}.pdf`;

        const command = new PutObjectCommand({
            Bucket: process.env.BUCKET_NAME,
            Key: `pdfs/${filename}`,
            Body: req.file.buffer,
            ContentType: 'application/pdf',
        });

        await s3Client.send(command);

        const fileUrl = `https://${process.env.BUCKET_NAME}.s3.${process.env.REGION}.amazonaws.com/pdfs/${filename}`;

        res.json({
            success: true,
            message: "File uploaded successfully",
            filename,
            url: fileUrl,
            key: `pdfs/${filename}`
        });

    } catch (error) {
        console.error("Upload error:", error);
        res.status(500).json({ error: "Upload failed", message: error.message });
    }
};

//for unity:

const getAllPurchases = async (req, res) => {
    try {
        const purchases = await Purchase.find()
            .populate("user", "organization email ")
            .populate("product", "productName childrenProducts")

        return res.json({
            success: true,
            count: purchases.length,
            purchases
        });

    } catch (error) {
        console.error("Get Purchases Error:", error);
        return res.status(500).json({
            success: false,
            message: "Failed to fetch purchases",
        });
    }
};



export {
    generateAccessAndRefreshToken,
    registerCustomerAndEngineer,
    login,
    logout,
    refreshAccessToken,
    changeCurrentPassword,
    addProductToCustomer,
    addNewProduct,
    updateAssignedProduct,
    getCustomerDetailsAndPurchases,
    createTicket,
    getTickets,
    getTicketById,
    getAllCustomers,
    getAllEngineers,
    getAllPurchasedProductsOfCustomer,
    getAllProducts,
    updateNewProduct,
    ticketDetailsSendToParties,
    forgotPassword,
    resetNewPassword,
    getCustomerDetails,
    updateCustomer,
    getCustomerById,
    getUpdatedProduct,
    updateEngineer,
    getEngineerById,
    fileUpload,
    getAllPurchases
}