import { verifyJWT } from "../middlewares/auth.middleware.js"
import { Product } from "../models/products.model.js";
import { Purchase } from '../models/purchase.model.js'
import { User } from "../models/user.model.js"
import { ApiError } from "../utils/ApiErrors.js"
import { ApiResponse } from "../utils/ApiResponse.js"
import { Ticket } from "../models/Tickets.model.js";
import { sendFeedbackEmail, sendOtpEmail, sendPasswordResetSuccessEmail, sendResetPasswordEmail, sendTicketEmailsToParties, sendTicketRaisedEmail, sendWelcomeEmailToCustomer, sendWelcomeEmailToEngineer } from "../utils/mailer.js";
import crypto from "crypto";
import bcrypt from 'bcrypt'
import { TempFormToken } from "../models/TempFormToken.model.js";
import jwt from "jsonwebtoken";
import { generatePresignedUrl, getObjectUrl } from "../utils/S3Client.js";
import { Feedback } from "../models/feedback.model.js";
import { randomUUID } from "crypto";
import { DeleteObjectCommand } from "@aws-sdk/client-s3";
// import { generatePresignedUrl } from "../utils/"


const generateRandomPassword = (length = 10) => {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@$!%*?&";
    let password = "";
    for (let i = 0; i < length; i++) {
        password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return password;
};


const generateAccessAndRefreshToken = async (userId) => {
    try {
        const user = await User.findById(userId)

        const accessToken = user.generateAccessToken()
        const refreshToken = user.generateRefreshToken()

        user.refreshToken = refreshToken
        await user.save({ validateBeforeSave: false })

        return { accessToken, refreshToken }

    } catch (error) {
        console.log("Error while generateing access and refresh token", error)
        throw new Error("Error while generating access and refresh token");
    }
}

const registerCustomer = async (req, res, next) => {
    try {
        const userDetails = req.body
        // console.log("user Details", email, firstName)

        if ([userDetails.organization, userDetails.email].some((field) => {
            return field?.trim() === ""
        })) {
            return res.status(400).json({ message: "Organization & Email fields are required" })
        }

        const existingUser = await User.findOne({ email: userDetails.email })

        console.log("Organization is already Exist with this email", existingUser)

        if (existingUser) {
            return res.status(400).json({ message: "Organization is already exist with this email", existingUser })
        }

        const autoGeneratedPassword = generateRandomPassword(12);

        const user = await User.create({
            firstName: userDetails.firstName,
            lastName: userDetails.lastName,
            email: userDetails.email,
            organization: userDetails.organization,
            password: autoGeneratedPassword,
            role: userDetails.role || "customer",
            address_1: userDetails.address_1,
            address_2: userDetails.address_2,
            country: userDetails.country,
            pinNumber: userDetails.pinNumber,
            phoneNumber: userDetails.phoneNumber,
        })

        const userCreated = await User.findById(user._id).select("-password")

        if (user.role === "customer") {
            await sendWelcomeEmailToCustomer(user.email, user.organization);
        } else if (user.role === "engineer") {
            await sendWelcomeEmailToEngineer(user.email, user.firstName, user.lastName);
        }

        if (!userCreated) {
            res.status(500).json({ message: "Something went wrong while registering user" })
        }

        return res.status(201).json(new ApiResponse(201, "User registered successfully", { userCreated, generatedPassword: autoGeneratedPassword }));

    } catch (error) {
        next(error);
    }
}

// const registerCustomerAndEngineer = async (req, res, next) => {
//     try {
//         const userDetails = req.body;
//         const role = userDetails.role || "customer";

//         let requiredFields = [];

//         if (role === "customer") {
//             requiredFields = ["email", "organization", "country", "phoneNumber"];
//         } else if (role === "commissioning_engineer") {
//             requiredFields = ["email", "firstName", "lastName", "country", "phoneNumber", "signatureUrl"];
//         }

//         const missing = requiredFields.filter((field) => {
//             const value = userDetails[field];
//             if (value === undefined || value === null) return true;
//             if (typeof value === "string" && value.trim() === "") return true;
//             if (typeof value !== "string" && !value) return true;
//             return false;
//         });

//         if (missing.length > 0) {
//             return res.status(400).json({
//                 message: `Missing required fields for ${role}: ${missing.join(", ")}`,
//             });
//         }

//         const existingUser = await User.findOne({ email: userDetails.email });

//         if (existingUser) {
//             return res.status(400)
//                 .json(new ApiError(400, "A user with this email already exists", ["Duplicate email"]));
//         }

//         const autoGeneratedPassword = generateRandomPassword(12);

//         const user = await User.create({
//             firstName: userDetails.firstName,
//             lastName: userDetails.lastName,
//             email: userDetails.email,
//             organization: userDetails.organization || null,
//             password: autoGeneratedPassword,
//             role: role,
//             address_1: userDetails.address_1,
//             address_2: userDetails.address_2,
//             country: userDetails.country,
//             pinNumber: userDetails.pinNumber,
//             phoneNumber: userDetails.phoneNumber,
//             signatureUrl: role === "commissioning_engineer" ? userDetails.signatureUrl : null
//         });

//         const userCreated = await User.findById(user._id).select("-password");

//         if (role === "customer") {
//             await sendWelcomeEmailToCustomer(user.email, user.organization, autoGeneratedPassword);
//         } else if (role === "commissioning_engineer") {
//             await sendWelcomeEmailToEngineer(user.email, user.firstName, user.lastName, autoGeneratedPassword);
//         }

//         return res.status(201).json(
//             new ApiResponse(201, "User registered successfully", {
//                 userCreated,
//                 generatedPassword: autoGeneratedPassword,
//             })
//         );

//     } catch (error) {
//         return next(
//             new ApiError(500, "Internal Server Error", [error.message], error.stack));
//     }
// };


const registerCustomerAndEngineer = async (req, res, next) => {
    try {
        const userDetails = req.body;
        const role = userDetails.role || "customer";

        const requiredFields =
            role === "commissioning_engineer"
                ? ["email", "firstName", "lastName", "country", "phoneNumber"]
                : ["email", "organization", "country", "phoneNumber"];

        const missing = requiredFields.filter((field) => !userDetails[field]);
        if (missing.length > 0) {
            return res.status(400).json({
                message: `Missing required fields for ${role}: ${missing.join(", ")}`,
            });
        }

        // let signatureUrl = null;

        // if (role === "commissioning_engineer") {
        //     if (!req.file) {
        //         return res.status(400).json({
        //             message: "Signature file is required for commissioning engineer",
        //         });
        //     }

        //     signatureUrl = await uploadToS3(req.file, "signatures");
        // }

        const existingUser = await User.findOne({ email: userDetails.email });
        if (existingUser) {
            return res.status(400).json({
                message: "A user with this email already exists",
            });
        }

        const autoGeneratedPassword = generateRandomPassword(12);

        const user = await User.create({
            firstName: userDetails.firstName,
            lastName: userDetails.lastName,
            email: userDetails.email,
            organization: userDetails.organization || null,
            password: autoGeneratedPassword,
            role: role,
            address_1: userDetails.address_1,
            address_2: userDetails.address_2,
            country: userDetails.country,
            pinNumber: userDetails.pinNumber,
            phoneNumber: userDetails.phoneNumber,
            signatureUrl: userDetails.signatureUrl,
        });

        const userCreated = await User.findById(user._id).select("-password");

        if (role === "customer") {
            await sendWelcomeEmailToCustomer(user.email, user.organization, autoGeneratedPassword);
        } else {
            await sendWelcomeEmailToEngineer(
                user.email,
                user.firstName,
                user.lastName,
                autoGeneratedPassword
            );
        }

        return res.status(201).json({
            message: "User registered successfully",
            userCreated,
            generatedPassword: autoGeneratedPassword,
        });

    } catch (error) {
        next(error);
    }
};


const login = async (req, res, next) => {

    try {
        console.log("user details", req.body)
        const { email, password } = req.body

        console.log("user details", email, password)
        if (!email || !password) {
            return res.status(400).json({ message: "All fields are required" })
        }


        const user = await User.findOne({ email })

        console.log("users", user)
        if (!user) {
            return res.status(400).json({ message: "user does not exist" })
        }

        const isPasswordCorrect = await user.isPasswordCorrect(password)

        if (!isPasswordCorrect) {
            return res.status(400).json({ message: "Password is not valid" })
        }

        const { accessToken, refreshToken } = await generateAccessAndRefreshToken(user._id)

        const loggedInUser = await User.findById(user._id).select("-password -refreshToken")

        const options = {
            httpOnly: true,
            secure: false
        }

        const response = new ApiResponse(200, "User logged in successfully", {
            user: loggedInUser,
            accessToken,
            refreshToken,
        });

        return res
            .status(response.statusCode)
            .cookie("accessToken", accessToken, options)
            .cookie("refreshToken", refreshToken, options)
            .json(response);

    } catch (error) {
        console.error("Error in login:", error);
        const errResponse = new ApiError(500, "Internal Server Error", [error.message]);
        return res.status(errResponse.statusCode).json(errResponse);
    }
}

const logout = async (req, res) => {
    try {
        await User.findByIdAndUpdate(
            req.user._id,
            { $unset: { refreshToken: 1 } },
            { new: true }
        );

        const options = {
            httpOnly: true,
            //   secure: process.env.NODE_ENV === "production", 
        };
        res
            .clearCookie("accessToken", options)
            .clearCookie("refreshToken", options);

        const response = new ApiResponse(200, "User logged out successfully");
        return res.status(response.statusCode).json(response);
    } catch (error) {
        console.error("Logout error:", error);
        const errResponse = new ApiError(500, "Internal Server Error", [error.message]);
        return res.status(errResponse.statusCode).json(errResponse);
    }
};

const forgotPassword = async (req, res) => {
    try {
        const { email } = req.body;

        if (!email) {
            return res.status(400).json(new ApiError(400, "Email is required"));
        }

        const user = await User.findOne({ email });

        if (!user) {
            return res.status(404).json({ message: "User not found" });
        }

        const resetToken = user.generatePasswordResetToken();

        await user.save({ validateBeforeSave: false });

        const resetUrl = `${process.env.FRONTEND_URL}/reset-password/${resetToken}`;

        await sendResetPasswordEmail(user.email, resetUrl);

        return res.status(200).json({
            message: "Reset password link sent to your email",
            resetToken,
            resetUrl
        });

    } catch (error) {
        console.error("Forgot Password Error:", error);
        return res.status(500).json({ message: "Internal Server Error" });
    }
};


const resetNewPassword = async (req, res) => {
    try {
        const { token } = req.params;
        const { password, confirmPassword } = req.body;

        if (!password || !confirmPassword) {
            return res.status(400).json({ message: "All fields are required" });
        }

        if (password !== confirmPassword) {
            return res.status(400).json({ message: "Passwords do not match" });
        }

        const hashedToken = crypto
            .createHash("sha256")
            .update(token)
            .digest("hex");

        const user = await User.findOne({
            resetPasswordToken: hashedToken,
            resetPasswordExpiry: { $gt: Date.now() },
        });

        console.log("reset user", user);

        if (!user) {
            return res.status(400).json({ message: "Invalid or expired token" });
        }

        user.password = password;

        user.resetPasswordToken = undefined;
        user.resetPasswordExpiry = undefined;

        await user.save();

        return res.status(200).json({
            message: "Password reset successful",
        });

    } catch (error) {
        console.error("Reset Password Error:", error);
        return res.status(500).json({ message: "Internal Server Error" });
    }
};


const changeCurrentPassword = async (req, res, next) => {
    try {
        const { oldPassword, newPassword, confirmPassword } = req.body;

        if (!oldPassword || !newPassword || !confirmPassword) {
            return res.status(400).json({ message: "All fields are required" });
        }

        if (newPassword !== confirmPassword) {
            return res.status(400).json({ message: "New password and confirm password do not match" });
        }

        const passwordRegex =
            /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;

        if (!passwordRegex.test(newPassword)) {
            return res.status(400).json({
                message:
                    "Password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one number, and one special character.",
            });
        }

        const user = await User.findById(req.user?._id);
        if (!user) {
            return res.status(404).json({ message: "User not found" });
        }

        const isPasswordValid = await user.isPasswordCorrect(oldPassword);
        if (!isPasswordValid) {
            return res.status(400).json({ message: "Old password is incorrect" });
        }

        if (oldPassword === newPassword) {
            return res.status(400).json({ message: "New password must be different from old password" });
        }

        user.password = newPassword;
        await user.save();

        user.refreshToken = undefined;
        await user.save();

        return res
            .status(200)
            .json(new ApiResponse(200, "Password changed successfully", {}));

    } catch (error) {
        console.error("Error changing password:", error);
        return res
            .status(500)
            .json(new ApiError(500, "Internal Server Error", [error.message]));
    }
}

const refreshAccessToken = async (req, res, next) => {
    const incomingRefreshToken = req.cookies.refreshToken || req.body.refreshToken

    if (!incomingRefreshToken) {
        return res.status(400).json({ message: "Unauthorized Token" })
    }
    try {
        const decodeToken = await verifyJWT(incomingRefreshToken, process.env.REFRESH_TOKEN_SECRET)
        const user = await User.findById(decodeToken?._id)

        if (!user) {
            throw new ApiError(401, "Invalid refresh token")
        }

        if (incomingRefreshToken !== user?.refreshToken) {
            throw new ApiError(401, "Refresh Token is expired or used")
        }

        const options = {
            httpOnly: true,
            // secure: true
        }

        const { accessToken, newRefreshToken } = await generateAccessAndRefreshToken(user._id)

        return res
            .status(200)
            .cookie("accessToken", accessToken, options)
            .cookie("refreshToken", newRefreshToken, options)
            .json(new ApiResponse(200, accessToken, refreshAccessToken), "Access Token Refreshed")
    } catch (error) {
        throw new ApiError(400, error.message || "Invalid Token")
    }
}

const addNewProduct = async (req, res, next) => {
    try {
        const { productName, productDetails, isVisibleInMobile } = req.body;

        if (!productName || productName.trim() === "") {
            return res.status(400).json(
                new ApiError(400, "Product name is required")
            );
        }

        if (isVisibleInMobile === undefined) {
            return res.status(400).json(
                new ApiError(400, "Mobile visibility is required")
            );
        }

        const existingProduct = await Product.findOne({
            productName: productName.trim(),
        });

        if (existingProduct) {
            return res.status(400).json(
                new ApiError(400, "Product already exists")
            );
        }

        const product = await Product.create({
            productName: productName.trim(),
            productDetails: productDetails?.trim(),
            isVisibleInMobile
        });

        return res
            .status(201)
            .json(new ApiResponse(201, "Product added successfully", product));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message])
        );
    }
};


const addProductToCustomer = async (req, res, next) => {
    try {
        const { projectNumber, productId, productSerialNumber, date } = req.body
        console.log("body 1 :", "number:", projectNumber, "prodID:", productId, "sr.no;", productSerialNumber, "data:", date)

        const { customerId } = req.params;

        console.log("userId", customerId)

        if (!projectNumber || !productId || !date) {
            return res
                .status(400)
                .json(
                    new ApiError(
                        400,
                        "productId, projectNumber, date are required.",
                        ["projectNumber, productId, and date must be provided"]
                    )
                );
        }

        const user = await User.findById(customerId);
        if (!user) {
            return res
                .status(404)
                .json(new ApiError(404, "Customer not found.", [`No customer with id: ${customerId}`]));
        }

        const product = await Product.findById(productId);
        if (!product) {
            return res
                .status(404)
                .json(new ApiError(404, "Product not found.", [`No product with id: ${productId}`]));
        }

        const existingPurchase = await Purchase.findOne({ projectNumber });
        if (existingPurchase) {
            return res
                .status(400)
                .json(new ApiError(400, "Project number already exists.", [`Project number "${projectNumber}" is already used`]));
        }

        const newPurchase = await Purchase.create({
            user: customerId,
            product: productId,
            projectNumber,
            date: new Date(date),
            productSerialNumber,
        });

        return res
            .status(201)
            .json(new ApiResponse(201, "Product assigned to customer successfully", newPurchase));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const updateAssignedProduct = async (req, res, next) => {
    try {
        const { purchaseId } = req.params;
        const { projectNumber, productId, productSerialNumber, date } = req.body;

        console.log("purchase dd:", "id:", purchaseId, productSerialNumber, date)

        const purchase = await Purchase.findById(purchaseId);
        if (!purchase) {
            return res
                .status(404)
                .json(new ApiError(404, "Purchase not found", [`No purchase with id: ${purchaseId}`]));
        }
        console.log("update details", "purchaseId", purchaseId, "body:", projectNumber, productId, productSerialNumber, date)

        if (projectNumber && projectNumber !== purchase.projectNumber) {
            const exists = await Purchase.findOne({ projectNumber });
            if (exists) {
                return res
                    .status(400)
                    .json(new ApiError(400, "Project number already exists", [`Project number "${projectNumber}" is already used`]));
            }
            purchase.projectNumber = projectNumber;
        }

        if (productId) {
            const product = await Product.findById(productId);
            if (!product) {
                return res
                    .status(404)
                    .json(new ApiError(404, "Product not found", [`No product with id: ${productId}`]));
            }
            purchase.product = productId;
        }

        if (productSerialNumber) {
            purchase.productSerialNumber = productSerialNumber;
        }

        if (date) {
            purchase.date = new Date(date);
        }

        console.log("update purchase detail: ", purchase, productId, productSerialNumber, date)
        await purchase.save();

        return res.status(200).json(
            new ApiResponse(
                200,
                "Project updated successfully",
                purchase
            )
        );

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const deleteProductFromCustomer = async (req, res, next) => {
    try {
        const { customerId, purchaseId } = req.params;

        const user = await User.findById(customerId);
        if (!user) {
            return res
                .status(404)
                .json(new ApiError(404, "Customer not found", [`No customer with id: ${customerId}`]));
        }

        const purchase = await Purchase.findOne({
            _id: purchaseId,
            user: customerId,
        });

        if (!purchase) {
            return res
                .status(404)
                .json(
                    new ApiError(
                        404,
                        "Assigned product not found",
                        ["No purchase found for this customer"]
                    )
                );
        }

        await purchase.deleteOne();

        return res
            .status(200)
            .json(new ApiResponse(200, "Product removed from customer successfully"));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};


const getCustomerDetailsAndPurchases = async (req, res) => {
    try {
        const { userId } = req.params;

        const purchase = await Purchase.find({ user: userId })
            .populate("product", "productName productDetails")
            .populate("user", "-password -refreshToken")
            .sort({ createdAt: -1 });

        return res
            .status(200)
            .json(new ApiResponse(200, "Customer products fetched successfully", purchase));
    } catch (error) {
        console.error("Error in getCustomerProducts:", error);
        return res.status(500).json(new ApiError(500, "Internal Server Error", [error.message]));
    }
};

const createTicket = async (req, res) => {
    try {
        const { productName, projectNumber, organization, issueDetails, issueType } = req.body;

        if (!productName || !projectNumber || !organization || !issueDetails || !issueType) {
            return res.status(400).json(
                new ApiError(400, "All mandatory fields must be provided", [
                    "productName, projectNumber, organization, issueDetails, issueType are required to enter."
                ])
            );
        }
        // console.log("body2:",productName, projectNumber, organization, issueDetails ,issueType)

        const organizationExists = await User.findOne({ organization });

        if (!organizationExists) {
            return res.status(400).json(
                new ApiError(400, "Invalid organization", [
                    `No organization found with name: ${organization}`
                ])
            );
        }
        const productExists = await Product.findOne({ productName });
        if (!productExists) {
            return res.status(400).json(
                new ApiError(400, "Invalid productName", [
                    `No product found with name: ${productName}`
                ])
            );
        }

        const purchaseExists = await Purchase.findOne({ projectNumber }).populate("product").populate("user");;
        if (!purchaseExists) {
            return res.status(400).json(
                new ApiError(400, "Invalid projectNumber", [
                    `No purchase found with projectNumber: ${projectNumber}`
                ])
            );
        }

        if (purchaseExists.product.productName !== productName) {
            return res.status(400).json(
                new ApiError(400, "Product mismatch", [
                    `Product name does not match the product linked with this projectNumber`
                ])
            );
        }

        const customerEmail = purchaseExists.user.email;

        const ticket = await Ticket.create({
            productName,
            projectNumber,
            organization,
            issueType,
            issueDetails,
            customerEmail,
            // dateTime: dateTime || Date.now(),
            user: req.user?._id || null
        });

        await sendTicketRaisedEmail(ticket.customerEmail, ticket);

        await sendTicketRaisedEmail(process.env.EMAIL_USER, ticket);

        return res.status(201).json(
            new ApiResponse(201, "Ticket created successfully", ticket)
        );

    } catch (error) {
        console.error("Error in createTicket:", error);
        return res.status(500).json(
            new ApiError(500, "Internal Server Error", [error.message])
        );
    }
};

// const getTickets = async (req, res) => {
//     try {
//         const tickets = await Ticket.find().sort({ createdAt: -1 });

//         return res.status(200).json(
//             new ApiResponse(200, "Tickets fetched successfully",   tickets )
//         );

//     } catch (error) {
//         console.error("Error in getTickets:", error);
//         return res.status(500).json(
//             new ApiError(500, "Internal Server Error", [error.message])
//         );
//     }
// };

const getTickets = async (req, res) => {
    try {
        const { year } = req.query;

        const start = year ? new Date(`${year}-01-01`) : null;
        const end = year ? new Date(`${year}-12-31`) : null;

        let query = {};

        if (req.user.role === "customer") {
            query.customerEmail = req.user.email;
        }

        if (year) {
            query.createdAt = { $gte: start, $lte: end };
        }

        const tickets = await Ticket.find(query).sort({ createdAt: -1 });

        const formatted = tickets.map(t => {
            const date = new Date(t.createdAt);

            const formattedDate = date.toLocaleDateString("en-GB", {
                day: "2-digit",
                month: "short",
                year: "numeric",
            });

            const formattedTime = date.toLocaleTimeString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                hour12: true
            });

            let replyDateFormatted = "";
            if (t.replyDate) {
                const rDate = new Date(t.replyDate);
                replyDateFormatted = rDate.toLocaleDateString("en-GB", {
                    day: "2-digit",
                    month: "short",
                    year: "numeric",
                });
            }

            return {
                ...t._doc,
                createdAtFormatted: `${formattedTime} ${formattedDate}`,
                replyDateFormatted
            };
        });

        return res.status(200).json(
            new ApiResponse(200, "Tickets fetched successfully", formatted)
        );
    } catch (error) {
        console.error("Error in getTickets:", error);
        return res.status(500).json(
            new ApiError(500, "Internal Server Error", [error.message])
        );
    }
};


const getTicketById = async (req, res) => {
    try {
        const { ticketId } = req.params;

        // Validate ID
        if (!ticketId || ticketId.trim() === "") {
            return res.status(400).json(
                new ApiError(400, "Ticket ID is required", [
                    "ticketId parameter is missing"
                ])
            );
        }

        // Find ticket
        const ticket = await Ticket.findById(ticketId)
            .populate("user", "email role")
            .populate("organization", "name");

        if (!ticket) {
            return res.status(404).json(
                new ApiError(404, "Ticket not found", [
                    `No ticket exists with ID: ${ticketId}`
                ])
            );
        }

        return res.status(200).json(
            new ApiResponse(200, "Ticket fetched successfully", ticket)
        );

    } catch (error) {
        console.error("Error in getTicketById:", error);
        return res.status(500).json(
            new ApiError(500, "Internal Server Error", [error.message])
        );
    }
};

const getAllCustomers = async (req, res, next) => {
    try {
        const customers = await User.find({ role: "customer" }).select("-password -refreshToken");

        return res.status(200).json(
            new ApiResponse(200, "Customers fetched successfully", customers)
        );
    } catch (error) {
        return next(
            new ApiError(500, "Error Fetching customer list", [error.message])
        )
    }
};

const getAllEngineers = async (req, res, next) => {
    try {
        const engineers = await User.find({ role: "commissioning_engineer" }).select("-password");

        return res.status(200).json(
            new ApiResponse(200, "Engineers fetched successfully", engineers)
        );
    } catch (error) {
        return next(
            new ApiError(500, "Error Fetch Engineer's list", [error.message])
        );
    }
};

const getAllPurchasedProductsOfCustomer = async (req, res, next) => {
    try {
        const { customerId } = req.params;

        const user = await User.findById(customerId);
        if (!user) {
            return res
                .status(404)
                .json(new ApiError(404, "Customer not found.", [`No customer with id: ${customerId}`]));
        }

        const purchases = await Purchase.find({ user: customerId })
            .populate({
                path: "product",
                select: "productName productDetails isVisibleInMobile childrenProducts",
                populate: {
                    path: "childrenProducts",
                    select: "productName productDetails isVisibleInMobile"
                }
            });

        return res
            .status(200)
            .json(new ApiResponse(200, "Purchases fetched successfully", purchases));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const getAllProducts = async (req, res, next) => {
    try {
        const products = await Product.find();

        return res
            .status(200)
            .json(new ApiResponse(200, "Products fetched successfully", products));
    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const updateNewProduct = async (req, res, next) => {
    try {
        const { productId } = req.params;
        const { productName, productDetails, isVisibleInMobile } = req.body;

        if (!productId) {
            return res.status(400).json({ message: "Product ID is required" });
        }

        if (productName && productName.trim() !== "") {
            const existingProduct = await Product.findOne({
                productName: productName.trim(),
                _id: { $ne: productId }
            });

            if (existingProduct) {
                return res
                    .status(400)
                    .json(new ApiError(400, "Another product with the same name already exists", [`Product name "${productName}" is already used`]));
            }
        }

        const updatedProduct = await Product.findByIdAndUpdate(
            productId,
            {
                ...(productName ? { productName: productName.trim() } : {}),
                ...(productDetails ? { productDetails: productDetails.trim() } : {}),
                ...(isVisibleInMobile !== undefined
                    ? { isVisibleInMobile: Boolean(isVisibleInMobile) }
                    : {})
            },
            { new: true }
        );

        if (!updatedProduct) {
            return res.status(404).json({ message: "Product not found" });
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Product updated successfully", updatedProduct));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const ticketDetailsSendToParties = async (req, res) => {
    try {
        const { ticketId } = req.params;
        const { optionalEmail, comment, synergyNumber } = req.body;

        console.log("optionEmail , comment , synergyNumber", optionalEmail, comment, synergyNumber)

        const ticket = await Ticket.findById(ticketId);
        if (!ticket) {
            return res.status(404).json({ message: "Ticket not found" });
        }

        if (ticket.emailSent) {
            return res.status(400).json({
                message: "Email already sent for this ticket. No further updates allowed."
            });
        }

        if (!comment) {
            return res.status(400).json({
                message: "Comment is required",
            });
        }


        ticket.comment = comment;
        if (optionalEmail) ticket.optionalEmail = optionalEmail;
        if (synergyNumber) ticket.synergyNumber = synergyNumber;

        ticket.status = "Resolved";
        ticket.replyDate = new Date();

        ticket.emailSent = true;

        await ticket.save();

        const emailPayload = {
            ticketId: ticket._id,
            projectNumber: ticket.projectNumber,
            productName: ticket.productName,
            issueDetails: ticket.issueDetails,
            issueType: ticket.issueType,
            organization: ticket.organization,
            customerEmail: ticket.customerEmail,
            status: ticket.status,
            comment,
            synergyNumber: synergyNumber || "N/A",
        };

        if (optionalEmail) {
            await sendTicketEmailsToParties(optionalEmail, emailPayload);
        }

        await sendTicketEmailsToParties(ticket.customerEmail, emailPayload);

        return res.status(200).json(
            new ApiResponse(
                200,
                "Project updated successfully",
                ticket
            )
        );
    } catch (error) {
        console.error("Error in takeTicketAction:", error);
        return res.status(500).json({
            message: "Internal Server Error",
            error: error.message,
        });
    }
};


const getCustomerDetails = async (req, res) => {
    try {
        const { userId } = req.params;

        const customer = await User.findById(userId);

        if (!customer) {
            return res.status(404).json(
                new ApiError(404, "Customer not found")
            );
        }

        return res.status(200).json(
            new ApiResponse(200, "Customer fetched successfully", customer)
        );

    } catch (error) {
        console.error("Error in getCustomerDetails:", error);
        return res.status(500).json(
            new ApiError(500, "Internal Server Error", [error.message])
        );
    }
};

const updateCustomer = async (req, res, next) => {
    try {
        const { userId } = req.params;
        const updates = req.body;

        delete updates.role;

        if (updates.email) {
            const existingUser = await User.findOne({ email: updates.email, _id: { $ne: userId } });
            if (existingUser) {
                return res
                    .status(400)
                    .json(new ApiError(400, "Another user with this email already exists"));
            }
        }

        const updatedUser = await User.findByIdAndUpdate(
            userId,
            { $set: updates },
            { new: true, runValidators: true, select: "-password" }
        );

        if (!updatedUser) {
            return res.status(404).json({ message: "User not found" });
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Customer updated successfully", updatedUser));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const getCustomerById = async (req, res) => {
    try {
        const customer = await User.findById(req.params.userId);

        if (!customer) {
            return res
                .status(404)
                .json(new ApiError(404, "Customer not found"));
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Customer fetched successfully", customer));

    } catch (error) {
        return next(
            new ApiError(500, "Error fetching customer", [error.message], error.stack)
        );
    }
};


const getUpdatedProduct = async (req, res) => {
    try {
        const product = await Product.findById(req.params.id);

        if (!product) {
            return res
                .status(404)
                .json(new ApiError(404, "Product not found"));
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Product fetched successfully", product));
    } catch (error) {
        return next(
            new ApiError(500, "Server error", [error.message], error.stack)
        );
    }
};


// const updateEngineer = async (req, res, next) => {
//     try {
//         const { id } = req.params;
//         const updates = req.body;

//         delete updates.role;

//         if (updates.email) {
//             const existingUser = await User.findOne({
//                 email: updates.email,
//                 _id: { $ne: id }
//             });

//             if (existingUser) {
//                 return res
//                     .status(400)
//                     .json(new ApiError(400, "Another engineer with this email already exists"));
//             }
//         }

//         const updatedEngineer = await User.findByIdAndUpdate(
//             id,
//             { $set: updates },
//             { new: true, runValidators: true, select: "-password" }
//         );

//         if (!updatedEngineer) {
//             return res
//                 .status(404)
//                 .json(new ApiError(404, "Engineer not found", [`No engineer found with id: ${id}`]));
//         }

//         return res
//             .status(200)
//             .json(new ApiResponse(200, "Engineer updated successfully", updatedEngineer));

//     } catch (error) {
//         return next(
//             new ApiError(500, "Internal Server Error", [error.message], error.stack)
//         );
//     }
// };

const updateEngineer = async (req, res, next) => {
    try {
        const { id } = req.params;

        const updates = { ...req.body };
        delete updates.role;

        if (req.file) {
            const uploadedKey = await uploadToS3(req.file);
            updates.signatureUrl = uploadedKey;
        }

        // Check unique email
        if (updates.email) {
            const existing = await User.findOne({
                email: updates.email,
                _id: { $ne: id }
            });

            if (existing) {
                return res.status(400)
                    .json(new ApiError(400, "Another engineer with this email already exists"));
            }
        }

        const updatedEngineer = await User.findByIdAndUpdate(
            id,
            { $set: updates },
            { new: true, runValidators: true, select: "-password" }
        );

        if (!updatedEngineer) {
            return res.status(404)
                .json(new ApiError(404, "Engineer not found"));
        }

        console.log("updated engineer details", updatedEngineer)

        return res.status(200)
            .json(new ApiResponse(200, "Engineer updated successfully", updatedEngineer));

    } catch (error) {
        return next(new ApiError(500, "Internal Server Error", [error.message]));
    }
};


const getEngineerById = async (req, res, next) => {
    try {
        const { id } = req.params;

        const engineer = await User.findOne({
            _id: id,
            role: "commissioning_engineer"
        }).select("-password -refreshToken");

        if (!engineer) {
            return res
                .status(404)
                .json(new ApiError(404, "Engineer not found", [`No engineer found with id: ${id}`]));
        }

        return res
            .status(200)
            .json(new ApiResponse(200, "Engineer fetched successfully", engineer));

    } catch (error) {
        return next(
            new ApiError(500, "Internal Server Error", [error.message], error.stack)
        );
    }
};

const fileUpload = async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: "No file uploaded" });
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = req.body.filename || `document-${timestamp}.pdf`;

        const command = new PutObjectCommand({
            Bucket: process.env.BUCKET_NAME,
            Key: `pdfs/${filename}`,
            Body: req.file.buffer,
            ContentType: 'application/pdf',
        });

        await s3Client.send(command);

        const fileUrl = `https://${process.env.BUCKET_NAME}.s3.${process.env.REGION}.amazonaws.com/pdfs/${filename}`;

        res.json({
            success: true,
            message: "File uploaded successfully",
            filename,
            url: fileUrl,
            key: `pdfs/${filename}`
        });

    } catch (error) {
        console.error("Upload error:", error);
        res.status(500).json({ error: "Upload failed", message: error.message });
    }
};


const uploadSignature = async (req, res) => {
    try {

        const { fileName, fileType, fileSize } = req.body;

        console.log("Received upload request =>", fileName, fileType, fileSize);

        if (!fileName || !fileType || !fileSize) {
            return res
                .status(400)
                .json({ message: "fileName and fileType are required." });
        }

        if (fileSize > 1024 * 1024) {
            return res.status(400).json({ message: "File size cannot exceed 1MB" });
        }

        const { uploadUrl, fileUrl, fileKey } = await generatePresignedUrl(fileName, fileType);

        return res.status(200).json({ message: "Upload URL generated successfully", uploadUrl, fileUrl, fileKey });

    } catch (error) {
        console.error("Error generating pre-signed URL:", error);
        res.status(500).json({
            message: "Failed to generate upload URL.",
            error: error.message,
        });
    }
};


const getSignedImageUrl = async (req, res) => {
    try {
        const key = req.query.key;

        if (!key) return res.status(400).json({ message: "Image key required" });

        const signedUrl = await getObjectUrl(key);
        res.json({ url: signedUrl });
    } catch (err) {
        console.error("Error generating signed image URL:", err);
        res.status(500).json({ message: "Failed to generate signed URL" });
    }
};

//for unity:
// const getAllPurchases = async (req, res) => {
//     try {
//         const purchases = await Purchase.find()
//             .populate("user", "organization email ")
//             .populate({
//                 path: "product",
//                 select: "productName childrenProducts",
//                 populate: {
//                     path: "childrenProducts",
//                     select: "productName productDetails"
//                 }
//             });


//         return res
//             .status(200)
//             .json(
//                 new ApiResponse(
//                     200,
//                     "Purchases fetched successfully",
//                     {
//                         count: purchases.length,
//                         purchases
//                     }
//                 )
//             );
//     } catch (error) {
//         return next(
//             new ApiError(
//                 500,
//                 "Internal Server Error",
//                 [error.message],
//                 error.stack
//             )
//         );
//     }
// };

const getAllPurchases = async (req, res, next) => {
    try {
        let query = {};

        if (req.user.role === "customer") {
            query.user = req.user._id;
        }

        const purchases = await Purchase.find(query)
            .populate("user", "organization email")
            .populate({
                path: "product",
                select: "productName childrenProducts",
                populate: {
                    path: "childrenProducts",
                    select: "productName productDetails"
                }
            });

        return res.status(200).json(
            new ApiResponse(
                200,
                "Purchases fetched successfully",
                {
                    count: purchases.length,
                    purchases
                }
            )
        );
    } catch (error) {
        return next(
            new ApiError(
                500,
                "Internal Server Error",
                [error.message],
                error.stack
            )
        );
    }
};


const getAllProjectDocs = async (req, res, next) => {
    try {
        const { projectNumber } = req.params;

        const purchase = await Purchase.findOne({ projectNumber });

        if (!purchase) {
            return next(
                new ApiError(
                    404,
                    "Project number not found",
                    [`Project ${projectNumber} does not exist`]
                )
            );
        }

        return res
            .status(200)
            .json(
                new ApiResponse(
                    200,
                    "Project docs fetched",
                    {
                        projectNumber: purchase.projectNumber,
                        preDocs: purchase.preDocs,
                        postDocs: purchase.postDocs
                    }
                )
            );

    } catch (error) {
        console.log("Error in getProjectDocs:", error);
        return next(
            new ApiError(
                500,
                "Internal Server Error",
                [error.message],
                error.stack
            )
        );
    }
};

const getPreDocs = async (req, res, next) => {
    try {
        const { projectNumber } = req.params;

        const purchase = await Purchase.findOne({ projectNumber });

        if (!purchase) {
            return next(
                new ApiError(
                    404,
                    "Project number not found",
                    [`Project ${projectNumber} does not exist`]
                )
            );
        }

        return res
            .status(200)
            .json(
                new ApiResponse(
                    200,
                    "Pre documentation fetched successfully",
                    {
                        projectNumber: purchase.projectNumber,
                        preDocs: purchase.preDocs
                    }
                )
            );

    } catch (error) {
        return next(
            new ApiError(
                500,
                "Internal Server Error",
                [error.message],
                error.stack
            )
        );
    }
};

const getPostDocs = async (req, res, next) => {
    try {
        const { projectNumber } = req.params;

        const purchase = await Purchase.findOne({ projectNumber });

        if (!purchase) {
            return next(
                new ApiError(
                    404,
                    "Project number not found",
                    [`Project ${projectNumber} does not exist`]
                )
            );
        }

        return res
            .status(200)
            .json(
                new ApiResponse(
                    200,
                    "Post documentation fetched successfully",
                    {
                        projectNumber: purchase.projectNumber,
                        postDocs: purchase.postDocs
                    }
                )
            );

    } catch (error) {
        console.log("Error in getPostDocs:", error);
        return next(
            new ApiError(
                500,
                "Internal Server Error",
                [error.message],
                error.stack
            )
        );
    }
};


const generateFormUrl = async (req, res) => {
    try {
        const { projectNumber, formName } = req.body;
        console.log("formName", projectNumber, formName)
        const { _id: userId, firstName, lastName, signatureUrl } = req.user;

        const purchase = await Purchase.findOne({ projectNumber }).populate("user")

        if (!purchase) {
            return res.status(404).json({ message: "No customer found for this project number", });
        }

        const customer = purchase.user;

        const EngineerDetails = `${firstName} ${lastName}`;
        const customerOrg = customer.organization
        const customerAddress = {
            address1: customer.address_1 || "",
            address2: customer.address_2 || ""
        };

        const EngineerSignature = `${signatureUrl}`;

        const tempToken = jwt.sign(
            { userId, projectNumber, formName, EngineerDetails, customerOrg, customerAddress, EngineerSignature },
            process.env.TEMP_TOKEN_SECRET,
            { expiresIn: "1h" }
        );

        await TempFormToken.create({
            token: tempToken,
            userId,
            projectNumber,
            formName,
            expiresAt: new Date(Date.now() + 60 * 60 * 1000)
        });

        const formRoutes = {
            "cold-commissioning": "cold-commissioning",
            "hot-commissioning": "hot-commissioning",
            "behavioural-observation": "behavioural-observation",
            "safety-walk-on-site": "safety-walk-on-site",
            "ready-to-startup": "ready-to-startup",
            "annexure-6": "annexure-6"
        };

        const route = formRoutes[formName];
        console.log("formName", formName)

        if (!route) {
            return res.status(400).json({ message: "Invalid formName" });
        }

        const url = `http://192.168.1.223:5173/form?token=${tempToken}`;

        return res.json({ url });

    } catch (err) {
        console.error("Generate Form URL Error:", err);
        return res.status(500).json({
            message: "Error generating URL",
            error: err.message
        });
    }
};

const sendFeedbackFormLink = async (req, res) => {
    try {
        const { projectNumber } = req.body;

        if (!projectNumber) {
            return res.status(400).json({ message: "Project number is required" });
        }

        const purchase = await Purchase
            .findOne({ projectNumber })
            .populate("user");

        if (!purchase || !purchase.user) {
            return res.status(404).json({ message: "Customer not found for project" });
        }

        const customer = purchase.user;

        const customerOrg = customer.organization;
        const customerAddress = {
            address1: customer.address_1 || "",
            address2: customer.address_2 || ""
        };


        const tokenId = randomUUID();

        const fileName = `Feedback.pdf`;

        const feedback = await Feedback.create({
            purchaseId: purchase._id,
            projectNumber,
            tokenId,
            status: "PENDING",
            fileName,
            submittedAt: null,
        });

        const feedbackToken = jwt.sign(
            {
                tokenId,
                userId: customer._id,
                purchaseId: purchase._id,
                projectNumber,
                purpose: "feedback",
                customerOrg,
                customerAddress
            },
            process.env.FEEDBACK_TOKEN_SECRET
        );

        console.log("feedbackToken", feedbackToken)

        const feedbackUrl =
            `${process.env.FRONTEND_URL}/feedback-form/${feedbackToken}`;

        await sendFeedbackEmail(
            customer.email,
            customer.firstName,
            feedbackUrl
        );

        res.status(200).json({
            message: "Feedback form email sent successfully"
        });

    } catch (error) {
        console.error("Send feedback error:", error);
        res.status(500).json({ message: "Failed to send feedback email" });
    }
};


const markDocumentFilled = async (req, res) => {
    try {
        const { projectNumber, formName } = req.user;

        console.log("projectNumber", projectNumber)
        console.log("formName", formName)

        const FORM_GROUP_MAP = {
            "behavioural-observation": "preDocs",
            "annexure-6": "preDocs",
            "safety-walk-on-site": "preDocs",
            "cold-commissioning": "postDocs",
            "hot-commissioning": "postDocs",
            "ready-to-startup": "postDocs"
        };

        const docsKey = FORM_GROUP_MAP[formName];

        console.log("docsKey", docsKey)

        const result = await Purchase.updateOne(
            {
                projectNumber,
                [`${docsKey}.$.formKey`]: formName,
                [`${docsKey}.$.isFilled`]: false
            },
            {
                $set: {
                    [`${docsKey}.$.isFilled`]: true,
                    [`${docsKey}.$.filledAt`]: new Date(),
                    [`${docsKey}.$.filledByEngineer`]: req.user.userId
                }
            }
        );

        console.log("result", result)

        if (result.modifiedCount === 0) {
            return res.status(400).json({
                message: "Document already submitted"
            });
        }


        const token = req.headers.authorization.split(" ")[1];
        await TempFormToken.updateOne(
            { token },
            { $set: { used: true } }
        );

        return res.json({ message: "Document submitted successfully" });

    } catch (err) {
        return res.status(500).json({
            message: "Error marking document filled",
            error: err.message
        });
    }
};


const getAllDocumentsByProjectNumber = async (req, res, next) => {
    try {
        const { projectNumber } = req.params;

        const result = await Purchase.aggregate([
            { $match: { projectNumber } },
            {
                $project: {
                    projectNumber: 1,
                    documents: {
                        $filter: {
                            input: {
                                $concatArrays: [
                                    {
                                        $map: {
                                            input: "$preDocs",
                                            as: "doc",
                                            in: { $mergeObjects: ["$$doc", { type: "pre" }] }
                                        }
                                    },
                                    {
                                        $map: {
                                            input: "$postDocs",
                                            as: "doc",
                                            in: { $mergeObjects: ["$$doc", { type: "post" }] }
                                        }
                                    }
                                ]
                            },
                            as: "doc",
                            cond: { $ne: ["$$doc.s3PdfUrl", null] }
                        }
                    }
                }
            }
        ]);

        if (!result.length) {
            return next(
                new ApiError(
                    404,
                    "Project not found",
                    [`No documents found for project ${projectNumber}`]
                )
            );
        }

        return res.status(200).json(
            new ApiResponse(200, result[0], "Documents fetched successfully")
        );
    } catch (error) {
        next(error);
    }
};

const getAllAttachDocument = async (req, res) => {

    try {
        const { userId, projectNumber } = req.params;

        // Find purchase by user and projectNumber
        const purchase = await Purchase.findOne({ user: userId, projectNumber });

        if (!purchase) {
            return res.status(404).json({ message: "Project not found" });
        }

        res.status(200).json({ attachDocuments: purchase.attachDocuments || [] });

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Failed to fetch attach documents" });
    }
};

const getAllFeedbacksFormsByProjectNumber = async (req, res) => {
    try {

        const { projectNumber } = req.params;

        const feedbacks = await Feedback.find({
            projectNumber,
            status: "SUBMITTED"
        })
            .sort({ submittedAt: -1 });

        res.json({
            count: feedbacks.length,
            data: feedbacks
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: "Failed to fetch feedbacks" });
    }
};


export const getFeedbackScoreForGraph = async (req, res) => {
    try {
        const { year } = req.query;

        const start = new Date(`${year}-01-01`);
        const end = new Date(`${year}-12-31`);

        const feedbacks = await Feedback.find(
            {
                status: "SUBMITTED",
                submittedAt: { $gte: start, $lte: end },
            },
            { scorePercentage: 1, submittedAt: 1 }
        );

        const allMonths = [
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        const monthlyData = {};
        allMonths.forEach(month => {
            monthlyData[month] = {
                month,
                total: 0,
                "80 or above": 0,
                "51-79": 0,
                "35-50": 0,
                "35 or below": 0,
            };
        });

        feedbacks.forEach(fb => {
            const percentage = Number(fb.scorePercentage);
            if (isNaN(percentage)) return;

            const date = new Date(fb.submittedAt);
            const monthName = allMonths[date.getMonth()];

            if (percentage >= 80) monthlyData[monthName]["80 or above"]++;
            else if (percentage >= 51) monthlyData[monthName]["51-79"]++;
            else if (percentage >= 35) monthlyData[monthName]["35-50"]++;
            else monthlyData[monthName]["35 or below"]++;

            monthlyData[monthName].total++;
        });

        res.status(200).json({
            success: true,
            data: allMonths.map(month => monthlyData[month]),
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: "Failed to fetch feedback stats" });
    }
};






// const sendFeedbackFormLink = async (req, res) => {
//     try {
//         const { projectNumber } = req.body;

//         if (!projectNumber) {
//             return res.status(400).json({ message: "Project number is required" });
//         }

//         const purchase = await Purchase.findOne({ projectNumber }).populate("user");

//         if (!purchase || !purchase.user) {
//             return res.status(404).json({ message: "Customer not found for project" });
//         }

//         const customer = purchase.user;

//         const feedbackToken = jwt.sign(
//             {
//                 userId: customer._id,
//                 purchaseId: purchase._id,
//                 projectNumber,
//                 purpose: "feedback"
//             },
//             process.env.FEEDBACK_TOKEN_SECRET,
//             // { expiresIn: "7d" }
//         );

//         const feedbackUrl = `${process.env.FRONTEND_URL}/feedback-form/${feedbackToken}`;

//         await sendFeedbackEmail(customer.email, customer.firstName, feedbackUrl);

//         res.status(200).json({
//             message: "Feedback form email sent successfully"
//         });
//     } catch (error) {
//         console.error("Send feedback error:", error);
//         res.status(500).json({ message: "Failed to send feedback email" });
//     }
// };




//update pre and post doc status is no use .
// const updatePreDocStatus = async (req, res) => {
//     try {
//         const { projectNumber, index } = req.params;
//         const { s3PdfUrl } = req.body;

//         const purchase = await Purchase.findOne({ projectNumber });
//         if (!purchase) {
//             return res.status(404).json({ success: false, message: "Purchase not found" });
//         }

//         if (!purchase.preDocs[index]) {
//             return res.status(400).json({ success: false, message: "Invalid pre-doc index" });
//         }

//         purchase.preDocs[index].isFilled = true;
//         purchase.preDocs[index].s3PdfUrl = s3PdfUrl;

//         await purchase.save();

//         res.json({
//             success: true,
//             message: "Pre-documentation updated successfully",
//             preDocs: purchase.preDocs
//         });

//     } catch (error) {
//         console.error(error);
//         res.status(500).json({ success: false, error: error.message });
//     }
// };

// const updatePostDocStatus = async (req, res) => {
//     try {
//         const { projectNumber, index } = req.params;
//         const { s3PdfUrl } = req.body;

//         const purchase = await Purchase.findOne({ projectNumber });
//         if (!purchase) {
//             return res.status(404).json({ success: false, message: "Purchase not found" });
//         }

//         if (!purchase.postDocs[index]) {
//             return res.status(400).json({ success: false, message: "Invalid post-doc index" });
//         }

//         purchase.postDocs[index].isFilled = true;
//         purchase.postDocs[index].s3PdfUrl = s3PdfUrl;

//         await purchase.save();

//         res.json({
//             success: true,
//             message: "Post-documentation updated successfully",
//             postDocs: purchase.postDocs
//         });

//     } catch (error) {
//         console.error(error);
//         res.status(500).json({ success: false, error: error.message });
//     }
// };


// export const verifyFormToken = (req, res) => {
//     try {
//         const authHeader = req.headers.authorization;
//         if (!authHeader)
//             return res.status(401).json({ message: "Unauthorized" });

//         const token = authHeader.split(" ")[1];
//         const decoded = jwt.verify(token, process.env.JWT_SECRET);

//         res.json({
//             success: true,
//             userId: decoded.userId,
//             projectNumber: decoded.projectNumber,
//             formName: decoded.formName
//         });
//     } catch (err) {
//         return res.status(401).json({ message: "Token expired or invalid" });
//     }
// };






export {
    generateAccessAndRefreshToken,
    registerCustomerAndEngineer,
    login,
    logout,
    refreshAccessToken,
    changeCurrentPassword,
    addProductToCustomer,
    addNewProduct,
    updateAssignedProduct,
    getCustomerDetailsAndPurchases,
    createTicket,
    getTickets,
    getTicketById,
    getAllCustomers,
    getAllEngineers,
    getAllPurchasedProductsOfCustomer,
    getAllProducts,
    updateNewProduct,
    ticketDetailsSendToParties,
    forgotPassword,
    resetNewPassword,
    getCustomerDetails,
    updateCustomer,
    getCustomerById,
    getUpdatedProduct,
    updateEngineer,
    getEngineerById,
    fileUpload,
    getAllPurchases,
    getAllProjectDocs,
    getPreDocs,
    getPostDocs,
    generateFormUrl,
    getSignedImageUrl,
    uploadSignature,
    sendFeedbackFormLink,
    markDocumentFilled,
    getAllDocumentsByProjectNumber,
    getAllAttachDocument,
    getAllFeedbacksFormsByProjectNumber,
    deleteProductFromCustomer
}